
## 作用域与闭包


* 什么是作用域

    - 编译器理论  传统的编译语言,编译一般需要3个步骤

        1. `分词/词法分析`: 把代码(字符串)打断成有意义的片段,称为token.


        2. `解析`: 将一个token的流(数组)转换为一个嵌套元素的语法书,表示程序的语法结构,这棵树称为"抽象语法树"(AST-Abstract Syntax Tree)

        3. `代码生成`: 将抽象语法树转换为可执行的代码(机器指令).如 `var = 2;` 的抽象语法树转换为机器指令, 分为两步 创建称为 a 的变量, 然后再 a 中存入一个值

        为了确保最快的性能, JS引擎的编译用了(JIT, 懒编译甚至是热编译)

    - 理解作用域

        分析JS引擎是如何执行 `var = 2;` 的:
        1. 编译器将程序分解成一系列的token, 生成AST树
        2. 遇到 `var 2` 编译器让作用域去查看变量`a`是否存在, 如果存在着继续前进, 如果不存在则让作用域声明 `a` 变量
        3. 编译器稍后执行代码,来处理赋值 a = 2, 引擎先让查看当前作用域集合是否有`a`变量可以访问, 若没有查看其他嵌套的作用域, 编译器处理赋值或获取变量的时候需要用到LHS查询和RHS查询
            ```javascript
                console.log(a)   //RHS引用
                a = 2            //LHS引用

                function foo(a) {   //a LHS
                    console.log( a ); //a RHS
                }

                foo( 2 );   //foo RHS
            ```
    - 嵌套作用域  即作用域栈
    - 错误
        为什么需要区别LHS和RHS?
        因为这两种类型的查询行为不同.
        如果 RHS 查询在嵌套的 作用域 的任何地方都找不到一个值，这会导致 引擎 抛出一个 ReferenceError。必须要注意的是这个错误的类型是 ReferenceError。

        现在，如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 null 或者 undefined 值的属性，那么 引擎 就会抛出一个不同种类的错误，称为 TypeError。
        ```javascript
            a = b     // Uncaught ReferenceError: b is not defined
            null.f()  //Uncaught TypeError: Cannot read property 'f' of null
        ```




* 词法作用域



* 函数与块作用域




* 提升



* 作用域闭包


* 附录
    - 动态作用域
    - 填补块作用域

        ES6引入了`let`, 让代码有了完整的块作用域的能力,但是在ES6之前如何使用块作用域?

        - 使用 IIFE(立即调用函数表达式)
        


    - this
