# 类型
1. 内建类型: 目前有7种, null, undefined, boolean, number, string, object, symbol    
    其中除了object, 其他6种被称为`基本类型` 
    使用`typeof`判断值的类型,我们最多可以得到7种结果: 6种内建对象`(null除外)`一对一的类型字符串值共6种+ `function`共1种, 一共7种结果.   
    ps: 上述并未考虑ES10的`bigInt`类型
2. 值作为类型
    在js中变量时没有类型的, 值才有类型
3. undefined vs undeclared  
    `undefined`与`undeclared`其实并非等价   
    undefined的意思是变量在作用域内已声明但未赋值;  
    undeclared的意思是变量在作用域内并没有声明
    ```
    var a;
    typeof a;  // undefined
    b;         // ReferenceError: b is not defined
    typeof b   // undefiend     注意: 这是一个大坑, undeclared的变量在typeof下也会返回 undefiend
    ```

# 值
1. Array    
    - 赋值长度会自动增加, 使用`delete`移除值长度不会减少
    - 松散数组
    - 以可以被强制转换成10进制的number的string值会变成number索引

2. 类Array
    - 以数字为key的对象
    - 可以使用`Array.from(arraylike)` 返回新的数组实例(浅拷贝)

3. String
    - 有自增的`length`属性, arraylike
    - 可以借助`call/apply`使用数组的方法("`非原地修改`的方法"), 用split&reverse&join代替reverse, 但是当存在`unicode`的复杂字符串时无法正常使用


4. Number
    - 包含"整数"和小数, js中"整数"只是一个没有小数部分的小数值, 也就是 42.0 === 42
    - 实现基于"IEEE 754"标准, 双精度("64位二进制")格式, [如何理解双精度](https://zhuanlan.zhihu.com/p/30703042)
    - 由于number系统是基于双精度标准实现的, 所以小数与小数运算时可能会出现精度不准的问题
    - 科学计数  5e5 === 5e+5 , 5E5 === 5e5  5.5e+5 === 550000
    - 进制:  十进制的 243 ===  十六进制的 0xf3/0Xf3  === 八进制的 0363/0o363  === 二进制的 0b11110011,  使用Number.toString(进制) 可以转换进制
    - 安全整数范围 双精度可以表示的最大值为  Number.MAX_VALUE === 2^1024 -1 约等于 1.7976931348623157e+308, 然而这个并不在安全范围内, 可以安全地被表示的最大整数其实为`Number.MAX_SAFE_INTEGER = 2^53 - 1`
5. 特殊值
    - null   空值
    - undefined  丢失的值
    - 特殊数字: 
        1. NaN
        ```
            typeof NaN          // "number"
            Number.isNaN("abc") // false, 会先判断参数是否为字符串
            isNaN("abc")        // true
            NaN != NaN          // true 永远不等于自己
        ```
        2. Infinity 无穷

6. 值与引用
    - 值有两种类型, 简单值和复杂值
    - 简单值: 值拷贝. null, undefined, string, number, boolean, symbol
    - 复杂值: 引用拷贝(即拷贝值引用的地址). object(包括array, 以及[所有对象的包装器](#原生类型))
    - js中由于没有指针,所以引用的工作方式与C++不一样(C++中是用特殊的声明符号来表示参数是引用类型), JS中所有引用都指向一个共享的复杂对象, 所有的引用都是共用一个对象

# 原生类型 
1. 常见的原生类型
    - String()
    - Number()
    - Boolean()
    - Symbol()
    - Object()
    - Array()
    - Function()
    - RegExp()
    - Date()
    - Error()

    ```javascript
        // 区分内建函数与基本类型两种方法创建的值
        var a = "abc"
        var b = new String("abc")
        console.log(a, b)       // abc String {"abc"}
        typeof a                // string
        typeof b                // object
        a == b                  // true
        a === b                 // false
        a instanceof String     // false
        b instanceof String     // false
        Object.prototype.toString.call(a)   //  "[object String]"
        Object.prototype.toString.call(b)   //  "[object String]"
        a.length                // 3       为什么"abc" 存在length属性, 是因为JS会自动包装基本类型值, 使他们可以用到原生类型的原生方法
        b.length                // 3
    ```

2. 内部 [[Class]]   
    typeof 的结果为 "object" 的值（比如数组）被额外地打上了一个内部的标签属性 [[Class]]（请把它考虑为一个内部的分类方法，而非与传统的面向对象编码的类有关）。       
    这个属性不能直接地被访问，但通常可以间接地通过在这个值上借用默认的 Object.prototype.toString(..)

3. 原生类型作为构造器
    - Array(...)  
        ```javascript
            // eg1: 如何生成一个 [1]的数组?
            var a = [1]
            var b = Array.from([1]) // arrayLike[, mapFn[, thisArg]
            var c = Array.of(1)     // element0, element1[, ...[, elementN]
            // 无法通过 new Array([1]) 或者 new Array(1) 或 Array([1]) 或 Array(1) 生成
            // 有 new 与没有 new的时候行为一致


            // eg2: 生成长度为3的空数组
            var aa = new Array(3)
            var bb = [ undefined, undefined, undefined ]
            var cc = []
            cc.length = 3       

            console.log(aa, bb, cc) 
            // chrome:   [empty × 3], [undefined, undefined, undefined], [empty × 3] 
            // aa与cc的创建方式是创建一个含有3个"空值槽"的数组 ,这样的数组称为松散数组, 与bb不一样

            aa.join( "-" ); // "--"
            bbb.join( "-" ); // "--"

            aa.map(function(v,i){ return i; }); // [ undefined x 3 ]
            bb.map(function(v,i){ return i; }); // [ 0, 1, 2 ]
            // map回调函数执行的时候会跳过"空值槽", 而join看起来更像是直接通过length遍历数组

            Array.apply(null, {length:3}) // apply执行的时候 {length:3} 可以看做是类数组[ undefined, undefined, undefined ], 所以等价于bb的创建结果

        ```
    - Date(..) 和 Error(..)     
        由于Date和Error都没有字面量形式所以只能使用构造器生成值     


# 强制转换
1. 转换值
    - 转换值总是 string, number, boolean等基本标量值
    - 隐含与明确    
        ```javascript
            var a = 42
            var b = a + ""  // 隐含强制转换
            var c = String(c) // 明确强制转换
        ```

2. 抽象值操作
    - ToString
        - number 会如预期运作, 指数形式时直接输出指数字符串
        - Object 会输出"[object `[[Class]]`]"
        - toString 可以明确被调用, 也可以在一个需要string上下文环境中使用一个非string来自动调用

    - JSON字符串化
        - 把一个值序列化为一个JSON兼容的字符串
        - JSON不安全的值有undefined, function, symbol, 内部循环引用的object. 他们对JSON结构来说都是非法值, 除了循环的object会报错之外, 其他值会被JSON.stringify自动忽略.
        - JSON.stringify 的第二个参数是`替换器`, 提供了过滤机制,指出object的哪些key可以存在哪些key会被跳过
        - JSON.stringify 的第三个参数是`填充符`,可以指示缩进应该用多少个空格符或自定义缩进内容

    - ToNumber
        - 使用 Number(xx) 转换
        - 如果参数不为基本类型, 则先通过`ToPrimitive`抽象操作获取基本类型(valueOf
        与toString), 若没有这两个方法则返回TypeError. (可以通过Object.create(null)创建)
        - todo
    - ToBoolean
        - `falsy`值表
            - undefined
            - null
            - false
            - -0, +0, NaN
            - ""
            - 浏览器的外来值如(document.all) 在IE的时候Boolean(document.all)为true, 现代浏览器会认为falsy
        - `truthy`值表
            - 不在`falsy`表中的值就是`truthy`
            - 已遗忘的`truthy`: [], {}, function fn(){}

3. 明确的强制转换
    - String <-> Number
        - 使用 toString()或String() 和 +-或Number()  相互转换
        - 5+ +"1" == 6
    - 从Date到Number
        - +new Date()  或 new Date().getTime()
    - 奇异的`~`, 按位取反
        - 二进制取补, 省略小数
        - ~42 === -(42 + 1)    或  ~-43 === -(-43 + 1)
        - 可以结合 ~a.indexOf(b)当不存在的时候该表达式为0, 而0又为falsy, 可以用于精简判断
        - `~~`可以对32位number有截断小数的效果
    - 解析数字字符串
        - parseInt 作用于String

4. 隐含的强制转换

5. 宽松等价与严格等价

6. 抽象关系比较


# 文法


# 附录