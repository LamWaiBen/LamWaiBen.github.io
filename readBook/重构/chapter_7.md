# 封装
编写代码时应该对用到的数据和函数都封装起来, 对后续的维护/重构都有很大的帮助.

## 封装记录
以数据类封装变量记录
- 动机  
记录型结构的数据并不容易理解各个字段中的关系, 可以使用类把数据的结构细节隐藏
- 范例  
    - 实用类的是私有变量把属性隐藏, 并通过函数把属性的访问/修改暴露
    - 封装嵌套记录, 当遇到对象记录的时候, 可以借助工具(lodash)把记录深拷贝, 且在访问记录的时候, 需要返回副本, 防止直接修改记录的数据.

## 封装集合
集合, 即离散hash, 映射map, 散列映射hashmap, 字典dictionary等数据结构.
- 动机  
集合的数据修改难以检测, 只有: 1.不直接返回集合(数据复制); 2. 通过代理返回集合并对集合的修改方法监听(数据代理)

## 以对象取代基本类型
以对象(类)取代数据值
- 动机  
有时候需要扩展新的字段来补充说明旧字段, 这时候可以考虑新建一个对象(类)来存放相关字段, 并把涉及到的逻辑存放这个类中.

## 以查询取代临时变量
- 动机  
虽然临时变量有时候可以避免重复计算, 但是它需要小心地维护而且可能会在多个函数中编写重复的逻辑. 

## 提炼类
与以对象取代基本类型类似, 把一些相关的字段提炼成一个类.
- 动机
当一个类里面存着一些和它不太相关的属性时, 可以尝试把这些属性提炼成一个新的类, 使不同的类之间的职责清晰明了.

## 内联类
与提炼类相反
- 动机  
当一个类不再承担足够责任时, 没有独有的字段时, 可以尝试把这个类删掉

## 隐藏委托关系
- 动机  
好的封装应该每个模块都应该尽可能少了解系统的其他部分, 这样做的好处是假如调用者并不需要调用的方法是来着本身还是其他类, 因为委托关系的依赖已经被隐藏.
- 做法  
把类中直接引用其他地方的属性/方法, 修改为把这个地方的对象挂载到类中, 改为this.xxx.fn 的方式来调用

## 移除中间人
与隐藏委托关系相反
- 动机  
当过度隐藏委托关系时, 随着委托类的功能越来越多, 过多的转发函数可能会使服务类变成一个中间人, 显得过于臃肿

## 替换算法
把新老算法都封装成独立函数, 替换后测试结果是否一致
