# 第一组重构
记录最常用/有用的一系列重构手法

## 提炼函数  
- 动机  
将意图和实现区分, 以函数名表示这段代码是做什么的.  
短函数的使用通常会被编译器优化(缓存), 所以不必过早担心性能问题.

- 范例  
大多数有3种情况:
    - 无局部变量
    - 有局部变量 --- 局部变量作为参数传入函数
    - 局部变量再赋值 --- 最好一个变量一个函数, 如果多个变量可以使用对象

## 内联函数
与提炼函数相反, 内联函数是把不合理的函数删掉, 合并到大型函数中
- 动机  
当代码有太多间接层时, 应该减少函数之间的委托, 把逻辑过于绕的函数内联.

## 提炼变量
引入解释性变量
- 动机  
当表达式过于复杂时, 可以引入多个解释性的变量, 使用变量来组合表达式

## 内联变量
与提炼变量相反, 当变量影响到重构时, 应该暂时使用内联变量使代码易于重构

## 改变函数声明
包括函数改名, 添加/删除参数, 修改签名
- 动机  
    - 函数名: 不能清晰表达函数做什么.
    - 参数: 函数列表使函数的应用范围受到限制, 涉及到传对象/基本类型的问题, 封装度与耦合度的衡量.
- 范例
    - 直接改名 --- 直接把原函数名改成新的函数名
    - 迁移式改名 --- 把原函数的代码迁移到新的函数中, 并在原函数中调用新函数且标记上deprecated
    - 添加参数 --- 增加一个参数, 同时使用断言(assert), 确保调用方有用到这个参数
    - 把参数改为属性 --- 由对象改为属性, 减少耦合度

## 封装变量
使用函数封装变量, 可以解除所有用到这个变量的代码对变量位置的依赖.
- 动机  
    - 假如数据变量允许直接访问的话, 在搬移变量后, 需要更改大量的代码, 所以把变量封装起来, 通过函数返回数据便于以后维护
    - 可以提供清晰的数据观测点, 以监控数据变化及获取
    - 不可变数据也重要, 不可变数据可以减少对数据的验证, 不用担心旧数据的问题
- 做法  
通过唯一函数的形式封装所有对数据的访问以及修改.
- 范例  
    - 封装数据 --- 限制数据的直接访问, 仅通过函数访问/修改
    - 封装值 --- 封装数据内值的访问/修改, 使其不会轻易被修改而导致出现不同值的副本

## 变量改名
如果有多个地方都用到这个变量时, 建议使用[封装变量](##封装变量)中的方法, 使用函数提供访问/修改

## 引入参数对象
- 动机  
使用对象把参数组织起来, 可以使参数列表变短, 以后也可以把这个对象提炼为类

## 函数组合成类
- 动机  
当发现一组函数在不停地操作同一块数据时, 可以把这组函数组合成类.  
避免在不同函数中有重复的逻辑代码.
- 做法  
    - 封装记录, 把共同数据封装起来放到类里面
    - 搬运函数, 把这组函数搬移到新类中
    - 提炼函数, 把涉及到这些函数的相关逻辑提炼成函数放到新类中
- 范例  
把所有的派生数据都改成在类中使用时计算得出, 组合出来的字段要符合统一访问原则

## 函数组合成变换
与函数组合成类相似, 函数组合成变换是指把一些数据喂到函数中, 经过变换后在函数的返回值中返回相应的数据
- 动机  
当一些派生数据在多处都有用到的时候, 可以把这些计算逻辑放到统一的一个函数中, 由这个函数统一返回计算后的数据, 这样做的好处是可以把所有相关的逻辑集中在一起,便于维护
- 做法  
    - 深复制输入数据
    - 提炼相关的计算逻辑到新的函数中

## 拆分阶段
- 动机  
当一段代码在同时是处理蒋健不同的事情时, 可以考虑把它拆分为两个阶段, 每个阶段只专注一个事情.  
编译器就是这样: 接受文本, 词法分析, token解析生成语法树, 语法树优化, 生成目标码. 按顺序每个阶段只做一件事情.
- 做法    
    1. 找出区分不同的阶段的边界
    2. 把第二阶段提炼函数, 临时变量暂时作为参数传进提炼的函数中
    3. 引入中转数据结构, 把不同阶段之间有联系的变量放到这个中转数据中, 并把部分重复的参数删除
    4. 把参数添加到中转数据结构后, 将第一阶段提炼函数, 使其返回中转数据结构
    5. 原函数中自此只需要调用各个阶段的函数, 通过第一阶段的返回值联系