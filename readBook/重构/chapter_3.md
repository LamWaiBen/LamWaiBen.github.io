# 代码的坏味道
什么样的代码会导致坏味道?
1. 神秘命名  
    使命名可以清晰表明自己的功能和用法
    - 改变函数声明 *124
    - 变量改名 *137
    - 字段改名 *244
2. 重复代码     
    把重复代码提炼成函数
    - 提炼函数 *106
    - 移动语句 *223
    - 函数上移 *350
3. 过长函数  
    把过长的函数分解成多个函数, 每个函数只做一件事情
    - 提炼函数 *106
    - 以查询取代临时变量 *178
    - 引入参数对象 *140
    - 保持对象完整 *319
    - 以命令取代函数 *337
    - 分解条件表达式 *260
    - 以多态取代条件表达式 *272
    - 拆分循环 *227
4. 过长参数列表  
    缩短每次调用函数需要传递的参数列表
    - 函数内部以查询取代参数 *324
    - 保持对象完整性 *319, 把整个对象作为参数
    - 引入参数对象 *140
    - 如果多个函数的参数基本一致, 函数组合成类 *144
5. 全局数据
    - 封装变量 *132, 使变量不会污染全局
6. 可变数据  
    函数式编程中, 要求数据不可改变. 
    可以把变量封装起来, 仅提供少数接口可以改变数据 避免其在预期不到的地方被改变.
7. 发散式变化  
    意味着在一个模块内,需要发散地在不同的上下文中执行函数  
    当一个模块的函数需要在不同的上下文切换时, 可以考虑把它才分为几个模块,每个模块只专注一个上下文.  
8. 霰弹式修改  
    与发散式变化类似, 每当遇到某种变化, 都必须在许多不同的类内做许多小修改.  
    更合理的代码应该要把不该分散的逻辑拽回来集中.
9. 依恋情结  
    模块化过程中, 可能存在一个函数跟另一个模块交互更频繁的情况.  
    更合理的应该是把这个函数移到另一个模块中.
10. 数据泥团
11. 基本类型偏执  
    有时候可能创建一个对象来代替基本类型表示的数据, 可能会更清晰
12. 重复的switch
    - 以多态取代条件表达式
13. 循环语句  
    - 以管道取代循环(filter, map, reduce), 可以更快明白代码的意图
14. 冗赘的元素  
    过度设计导致的冗余元素
15. 夸夸其谈通用性  
    过度设计导致的冗余设计
16. 临时字段
17. 过长的信息链  
    遇到过长的调用链(一个对象请求另一个对象)时,   
    需要隐藏委托关系, 把所有中间对象都变成'中间人'.
18. 中间人  
    封装往往伴随委托.  
    当过多委托与中间人时, 需要移除中间人, 应直接和负责对象交互.
19. 内幕交易  
    当两个模块中太多数据交互时, 可以找到共同的地方,  
    把这些共同数据放在管理良好的地方
20. 过大的类  
    与过大的函数一样, 过大的类也会造成难以维护, 重复代码杂生, 应该适当分为几个类
21. 异曲同工的类  
    不同的类保持一致的接口时, 当需要替换类时不需要更改太多的代码
22. 纯数据的类  
    为了便于维护类里面的数据, 应该尽可能使用私有变量,仅可以通过类的方法修改
23. 被拒绝的遗赠  
    如果子类复用了超类的行为, 却又不愿意支持超类的接口. 这时应该考虑是否坚持使用继承体系来编写代码
24. 注释  
    当不得不尝试写注释解释代码时, 可以想下是否可以把重构使其易懂