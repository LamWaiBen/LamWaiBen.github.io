# 浏览器跨域问题

## CORS跨域资源共享


## jsonp


## 修改document.domain(仅适用于不同子域)



## 使用window.name与iframe



## h5的window.postMessage



## webpack的http-proxy-middleware模块



## 遇到的坑

### credentials
默认情况下标准的跨域请求是不会发送cookie等用户认证凭据的, 所以每一次访问远程api的时候, 服务器都会认为你还没有登录. 所以就出现了 `xhr.withCredentials = true`.  
```
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://www.xxx.com/api');
xhr.withCredentials = true;
xhr.onload = onLoadHandler;
xhr.send();
```
这样跨域请求时, cookie的相关信息就会被带上了.  

同时服务端方面也需要做一定的处理, 在响应头中设置 `Access-Control-Allow-Credentials: true`, 否则服务器会报错.  
```
responce.set('Access-Control-Allow-Credentials', 'true');
```

好了, 这时候有个坑来了.
由于现在跨域请求都会携带cookie, 为了安全问题, 服务器就不能把 Access-Control-Allow-Origin 设置为 * 了, 
如果不设置为` * `, 只能设置某一个固定的域名`http://xxx.com`, 这样又会导致只允许这个域名的请求会被接收.
为了要解决这个问题, 只能在每一次请求的时候, 都根据请求的origin 来设置跨域.
```
responce.set('Access-Control-Allow-Origin', request.get('origin'));
```

## 参考文章: 

[浏览器跨域访问解决方案](https://www.haorooms.com/post/js_kuayu_service)  
[浏览器跨域请求之credentials](https://blog.csdn.net/vincent_ling/article/details/51714691)
