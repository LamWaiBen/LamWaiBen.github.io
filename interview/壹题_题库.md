# 题库
题目在前, 答案在后
    
## 题目

### 第 1 题: 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？
解析: [思路](#第1题:)

### 第 2 题: ['1', '2', '3'].map(parseInt) what & why ?
解析: [思路](#第2题:)

### 第 3 题：什么是防抖和节流？有什么区别？如何实现？
解析: [思路](#第3题:)

### 第 4 题：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？
解析: [思路](#第4题:)

### 第 5 题：介绍下深度优先遍历和广度优先遍历，如何实现？
解析: [思路](#第5题:)

### 第 6 题：请分别用深度优先思想和广度优先思想实现一个拷贝函数？
解析: [思路](#第6题:)

### 第 7 题：ES5/ES6 的继承除了写法以外还有什么区别？
解析: [思路](#第7题:)

### 第 8 题：setTimeout、Promise、Async/Await 的区别
解析: [思路](#第8题:)

### 第 9 题：Async/Await 如何通过同步的方式实现异步
解析: [思路](#第9题:)


### 第 10 题：异步笔试题
> 请写出下面代码的运行结果
```javascript
    async function async1() {
        console.log('async1 start');
        await async2();
        console.log('async1 end');
    }
    async function async2() {
        console.log('async2');
    }
    console.log('script start');
    setTimeout(function() {
        console.log('setTimeout');
    }, 0)
    async1();
    new Promise(function(resolve) {
        console.log('promise1');
        resolve();
    }).then(function() {
        console.log('promise2');
    });
    console.log('script end');
```
解析: [思路](#第10题:)


























## 思路

### 第1题:
考察`diff算法`对数组模板的处理        

tag: [diff算法](http://hcysun.me/vue-design/zh/renderer-diff.html#%E5%87%8F%E5%B0%8Fdom%E6%93%8D%E4%BD%9C%E7%9A%84%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80)

数据模型为数组时, 有/无key的两种不同diff方案
- 无key
    1. 数据位置替换时, `就地复用`原来的子节点, 仅更新被观察的属性
    2. 数据增删时, `就地复用`原来的子节点, 仅更新被观察的属性, 再添加或删除节点
    3. 在简单模板的情况下, 速度较有key会快一点, 因为可以有效复用节点,不用在节点增删上消耗时间.     
- 有key
    1. 数据位置替换时, 根据key找到对应dom, dom节点位置进行交换
    2. 数据增删时, 删除被删掉的dom节点, 重新生成带有新key的dom节点
    3. 可以更准确(根据key对比), 更快速(key可以组成map对象)获取到对应的节点

答案: [详细答案](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1)


### 第2题:
考察`Array.prototype.map` 和 `parseInt`的参数
tag: Array, parseInt, 进制

- Array.prototype.map(callback)
    - callback(currentValue, index, currentArray)
        - currentValue
        - index
        - currentArray

- parseInt(string, radix)   把字符串string当做radix进制的值,  返回string在十进制下的数值
    - string,  被处理的字符串
    - radix,   解析时的基数, 范围: [2, 36]


```javascript
[1,2,3].map(parseInt)       // [1, NaN, NaN]
// 相当于
[
    parseInt(1, 0),         // 1, 基数为0时, string不以"0x"或"0"开头, 则基数为10
    parseInt(2, 1),         // NaN, radix范围不正确, 1不在[2, 36]内
    parseInt(3, 2)          // NaN, 3 不是有效地二进制值
]


// 变式:
let unary = fn => val => fn(val)        // let unary = fn => (val, index) => fn(val, index)
let parse = unary(parseInt)
console.log(['1.1', '2', '0.3'].map(parse))

```
[parseInt方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)


### 第3题:
考察 异步编程, 优化思路, 闭包       
tag: setTimeout, 防抖节流, 闭包

- 防抖: 请求需要在一定时间内不重复触发, 之后才会执行, 如果在这个时间内又发送请求则重新计算时间
- 节流: 请求在一定时间区间内只会执行一次, 
```javascript
// 防抖
function debounce(fn, ms, ...args){
    let timeoutId = 0
    return e => {
        if(timeoutId) clearTimeout(timeoutId)
        // setTimeout 函数内的上下文为window, 所以需要绑定上下文
        timeoutId = setTimeout(() => fn.apply(this, [e, ...args]), ms)  
    }
}

// 节流
function throttle(fn, ms, ...args){
    let time = 0
    return e => {
        if(Date.now() - time < ms) return
        time = Date.now()
        setTimeout(() => fn.apply(this, [e, ...args]), ms) 
    }
}
```


### 第4题:
考察 ES6        

- Set: 成员不重复的类似数组的数据结构
- Map: 可以以任意值(包括引用类型的值))为key的数据结构
- WeakSet: `成员只能是对象且对成员的引用为弱引用`, 不计入引用次数, 成员可以被回收,  不能遍历不能清空
- WeakMap: 与Map不同的点是, `key只能是对象且对key的引用为弱引用`, 不计入引用次数, key可以被回收, 不能遍历不能清空

共同特点:         
1. 无法直接与JSON相互转换    
    

### 第5题:
考察 算法, DFS, BFS

- 深度优先遍历(DFS)      
    1. 从根节点起,选择某一个分支, 一直往子分支迭代,直到尽头再重新回到路线最初的分叉点从新开始迭代另一分支
    2. 可以用`递归`或`栈`实现
- 广度优先遍历(BFS)      
    1. 从根节点起, 先迭代同一层级的子分支, 然后再迭代子分支的子分支(孙代分支).
    2. 可以用`队列`实现

```javascript
// 假设节点都在children数组中

// 深度优先遍历(DFS)      递归
function dfs(node, nodeList = []){
    if(node){
        nodeList.push(node)
        let children = node.children
        for(let v of children){
            dfs(v, nodeList)
        }
    }
    return nodeList
}

// 广度优先遍历(BFS)      队列
function bfs(node){
    let nodes = []
    let stacks = []
    if(node){
        stacks.push(node)
        while (stacks.length) {
            node = stacks.shift()
            nodes.push(node)
            for(let childNode of node.children){
                stacks.push(childNode)
            }
        }
    }
    return nodes
}

```


### 第6题:
考察 拷贝函数, DFS, BFS
- 深拷贝函数, 需要注意的点:
    - Object
        - object
        - array
        - Map/Set
        - 其他类型及其原型链(Date, RegExp...)
    - Symbol
    - function
    - 内部引用的处理
```javascript
    function getEmpty(o) {
        let constructor = o.constructor
        if(constructor == Object) return {}
        else if(constructor == Array) return []
        else if(constructor == Date) return new Date(o)
        else if(constructor == RegExp) return new RegExp(o)
        else if(constructor == Map) return new Map(o)       // 浅复制
        else if(constructor == Set) return new Set(o)       // 浅复制
        return o;
    }

    // DF 深度优先   栈实现
    function deepCopy_df_stack(param) {
        let res = getEmpty(param)
        let quoteMap = new WeakMap()
        let stacks = []
        if(typeof param == "object"){
            if(quoteMap.has(param)) return quoteMap.get(param)
            quoteMap.set(param, res)
            stacks.push([param, res])
        }else if(typeof param == "function"){
            res = eval('(' + param.toString() + ')')
        }

        while (stacks.length) {
            let [ori, tar] = stacks.pop()       // 先进后出
            for(let key in ori){
                if(quoteMap.get(ori[key])){
                    tar[key] = quoteMap.get(ori[key])
                    continue
                }
                
                tar[key] = getEmpty(ori[key])
                if (typeof ori[key] == "object"){
                    stacks.push(ori[key], tar[key])
                    quoteMap.set(ori[key], tar[key])
                } else if (typeof param == "function") {
                    res = eval('(' + param.toString() + ')')
                }
            }
        }
        return res
    }

    // BF 广度优先   队列实现
    function deepCopy_bf_queue(param) {
        let res = getEmpty(param)
        let quoteMap = new WeakMap()
        let queue = []
        if (typeof param == "object") {
            if (quoteMap.has(param)) return quoteMap.get(param)
            quoteMap.set(param, res)
            queue.push([param, res])           
        } else if (typeof param == "function") {
            res = eval('(' + param.toString() + ')')
        }

        while (queue.length) {
            let [ori, tar] = queue.shift()      // 先进先出
            for (let key in ori) {
                if (quoteMap.get(ori[key])) {
                    tar[key] = quoteMap.get(ori[key])
                    continue
                }

                tar[key] = getEmpty(ori[key])
                if (typeof ori[key] == "object") {
                    queue.push(ori[key], tar[key]) 
                    quoteMap.set(ori[key], tar[key])
                } else if (typeof param == "function") {
                    res = eval('(' + param.toString() + ')')
                }
            }
        }
        return res
    }
```


### 第7题:
考察 ES6, Class, 继承, 原型

- ES5继承
    - 原型链继承  
        - 将一个父类的实例赋值给子类的构造函数的原型。
        - 实例的constructor依然指向父类的构造函数
        - 所有实例都共享同一个父类原型, 修改原型上的引用属性会影响所有子类
    - 构造函数继承  
        - 在子类的构造函数内部调用父类构造函数, 通过使用apply或call方法调用可以在子类实例化的时候执行父类构造函数
        - 可以传递属性, 父类的属性会设置在子类上
        - 父类中定义的方法子类实例无法调用, 同样的方法都要在子类上写一遍
    - 组合式继承  
        - 既使用原型链实现对原型属性和方法的继承，用借用构造函数模式实现对实例属性的继承.
        - 原型上定义的方法可以复用, 每个实例也都有自己的属性
        - 需要调用两次父类构造函数
    - 原型式继承
        - 改造`原型链继承`, 不使用父类的构造函数创建实例, 使用父类的原型创建新的对象作为子类实例
        - Object.create(proptotype, childObj)
        - 与`原型链继承`有一样的缺点, 修改父类原型上的引用属性会影响所有子类
    - 寄生式继承
        - 在`原型式继承`的基础上为对象添加函数, 增强对象
        - 无法函数复用, 与`构造函数继承`类似
    - 寄生组合式继承
        - `寄生式继承`和`组合式继承`的结合, 借助`构造函数`继承属性, 又用过`原型链`继承方法
        - 与`组合式继承`的主要区别在于 前者原型使用的是父类的一个副本, 后者直接使用父类的实例作为原型
        - 只调用一次父类构造函数, 子类原型上不需要创建多余的属性, 原型链可以保持不变, 可以正常使用instanceof isPrototypeOf 方法.
- class
    - `寄生组合式继承`的语法糖
    - class之间使用`extends`关键字继承, 子类的constructor中必须调用super方法猴才能使用this, 因为子类没有自己的this对象,而是继承父类的this对象
- 区别点
    1. `class` 声明会提升, 但是不会赋值, 会进入暂时性死区(TDZ), 类似于`let`, `const`
    2. `class` 内部会启用严格模式
    3. `class` 所有方法都是不可枚举的, 也没有原型对象,所以无法使用`new`来调用
    4. `class` 内部无法重写类名。
```javascript
    //寄生组合式继承
    function inheritPrototype(subType, superType){
        let prototype = Object.create(superType)    // 创建副本对象
        prototype.constructor = subType             // 增加对象, 改变构造函数的指向
        subType.prototype = prototype               // 指向原型
    }

    function superType(name){
        this.name = name
        this.colors = ["red", "green", "blue"]
    }
    superType.prototype.sayName = function (){
        console.log(this.name)
    }

    function subType(name, age){
        superType.call(this, name)          // 继承属性
        this.age = age
    }
    
    inheritPrototype(subType, superType)    // 继承方法
    subType.prototype.sayAge = function(){
        console.log(this.age)
    }


    // ES6
    class SuperType{}
    class SubType extends SuperType{}
    SubType.__proto__ === SuperType                         //true, 继承属性
    SubType.prototype.__proto__ === SuperType.prototype     //true, 继承方法

    // 因为 
    // SubType.prototype.__proto__ === SuperType.prototype 
    // sub.__proto__ == SubType.prototype 
    // 所以
    let sub = new SubType()
    sub.__proto__.__proto__ === SuperType.prototype         // true
```
![图片](../pic/ES6_class.png)


### 第8题:
考察 异步, EventLoop
- macrotask queue
    - 宏任务队列: 本质是浏览器多个线程之间通信的一个消息队列, 可能会有多个宏队列
    - 属于宏任务的有: setTimeout, setInterval, setImmediate, requestAnimationFrame
- microtask queue
    - 微任务队列: 只有一个队列, `每执行一个宏任务后`,都会执行为任务队列中的所有任务内容
    - 属于微任务的有: MutationObserver, promise的回调, process.nextTick


### 第9题:
考察 async/await, generator

- 借助ES6的`generator`函数, 包装了`yield`操作符与`next`方法, 使其看起来像是同步的代码
- 基本原理如下: [bAsync](../code/doOneself/bAsync/bAsync.js)



### 第10题:
考察 EventLoop, 异步

```
----------------- macrotask 开始
script start
async1 start
async2
promise1
script end
----------------- macrotask 结束
----------------- microtask 开始
async1 end
promise2
----------------- microtask 结束
----------------- macrotask 开始
setTimeout
----------------- macrotask 结束
```
[变式-举一反三](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7)
