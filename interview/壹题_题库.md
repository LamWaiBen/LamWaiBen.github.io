# 题库
题目在前, 答案在后
    
## 题目

### 第 1 题: 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？
解析: [思路](#第1题:)

### 第 2 题: ['1', '2', '3'].map(parseInt) what & why ?
解析: [思路](#第2题:)

### 第 3 题：什么是防抖和节流？有什么区别？如何实现？
解析: [思路](#第3题:)

### 第 4 题：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？
解析: [思路](#第4题:)

### 第 5 题：介绍下深度优先遍历和广度优先遍历，如何实现？
解析: [思路](#第5题:)

### 第 6 题：请分别用深度优先思想和广度优先思想实现一个拷贝函数？
解析: [思路](#第6题:)































## 思路

### 第1题:
考察`diff算法`对数组模板的处理        

tag: [diff算法](http://hcysun.me/vue-design/zh/renderer-diff.html#%E5%87%8F%E5%B0%8Fdom%E6%93%8D%E4%BD%9C%E7%9A%84%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80)

数据模型为数组时, 有/无key的两种不同diff方案
- 无key
    1. 数据位置替换时, `就地复用`原来的子节点, 仅更新被观察的属性
    2. 数据增删时, `就地复用`原来的子节点, 仅更新被观察的属性, 再添加或删除节点
    3. 在简单模板的情况下, 速度较有key会快一点, 因为可以有效复用节点,不用在节点增删上消耗时间.     
- 有key
    1. 数据位置替换时, 根据key找到对应dom, dom节点位置进行交换
    2. 数据增删时, 删除被删掉的dom节点, 重新生成带有新key的dom节点
    3. 可以更准确(根据key对比), 更快速(key可以组成map对象)获取到对应的节点

答案: [详细答案](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1)


### 第2题:
考察`Array.prototype.map` 和 `parseInt`的参数
tag: Array, parseInt, 进制

- Array.prototype.map(callback)
    - callback(currentValue, index, currentArray)
        - currentValue
        - index
        - currentArray

- parseInt(string, radix)   把字符串string当做radix进制的值,  返回string在十进制下的数值
    - string,  被处理的字符串
    - radix,   解析时的基数, 范围: [2, 36]


```javascript
[1,2,3].map(parseInt)       // [1, NaN, NaN]
// 相当于
[
    parseInt(1, 0),         // 1, 基数为0时, string不以"0x"或"0"开头, 则基数为10
    parseInt(2, 1),         // NaN, radix范围不正确, 1不在[2, 36]内
    parseInt(3, 2)          // NaN, 3 不是有效地二进制值
]


// 变式:
let unary = fn => val => fn(val)        // let unary = fn => (val, index) => fn(val, index)
let parse = unary(parseInt)
console.log(['1.1', '2', '0.3'].map(parse))

```
[parseInt方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)


### 第3题:
考察 异步编程, 优化思路, 闭包       
tag: setTimeout, 防抖节流, 闭包

- 防抖: 请求需要在一定时间内不重复触发, 之后才会执行, 如果在这个时间内又发送请求则重新计算时间
- 节流: 请求在一定时间区间内只会执行一次, 
```javascript
// 防抖
function debounce(fn, ms, ...args){
    let timeoutId = 0
    return e => {
        if(timeoutId) clearTimeout(timeoutId)
        // setTimeout 函数内的上下文为window, 所以需要绑定上下文
        timeoutId = setTimeout(() => fn.apply(this, [e, ...args]), ms)  
    }
}

// 节流
function throttle(fn, ms, ...args){
    let time = 0
    return e => {
        if(Date.now() - time < ms) return
        time = Date.now()
        setTimeout(() => fn.apply(this, [e, ...args]), ms) 
    }
}
```


### 第4题:
考察 ES6        

- Set: 成员不重复的类似数组的数据结构
- Map: 可以以任意值(包括引用类型的值))为key的数据结构
- WeakSet: `成员只能是对象且对成员的引用为弱引用`, 不计入引用次数, 成员可以被回收,  不能遍历不能清空
- WeakMap: 与Map不同的点是, `key只能是对象且对key的引用为弱引用`, 不计入引用次数, key可以被回收, 不能遍历不能清空

共同特点:         
1. 无法直接与JSON相互转换    
    

### 第5题:
考察 算法, DFS, BFS

- 深度优先遍历(DFS)      
    1. 从根节点起,选择某一个分支, 一直往子分支迭代,直到尽头再重新回到路线最初的分叉点从新开始迭代另一分支
    2. 可以用`递归`或`栈`实现
- 广度优先遍历(BFS)      
    1. 从根节点起, 先迭代同一层级的子分支, 然后再迭代子分支的子分支(孙代分支).
    2. 可以用`队列`实现

```javascript
// 假设节点都在children数组中

// 深度优先遍历(DFS)      递归
function dfs(node, nodeList = []){
    if(node){
        nodeList.push(node)
        let children = node.children
        for(let v of children){
            dfs(v, nodeList)
        }
    }
    return nodeList
}

// 广度优先遍历(BFS)      队列
function bfs(node){
    let nodes = []
    let stacks = []
    if(node){
        stacks.push(node)
        while (stacks.length) {
            node = stacks.shift()
            nodes.push(node)
            for(let childNode of node.children){
                stacks.push(childNode)
            }
        }
    }
    return nodes
}

```


### 第6题:
考察 拷贝函数, DFS, BFS
- 深拷贝函数, 需要注意的点:
    - Object
        - object
        - array
        - Map/Set
        - 其他类型及其原型链(Date, RegExp...)
    - Symbol
    - function
    - 内部引用的处理
```javascript
    function getEmpty(o) {
        let constructor = o.constructor
        if(constructor == Object) return {}
        else if(constructor == Array) return []
        else if(constructor == Date) return new Date(o)
        else if(constructor == RegExp) return new RegExp(o)
        else if(constructor == Map) return new Map(o)       // 浅复制
        else if(constructor == Set) return new Set(o)       // 浅复制
        return o;
    }

    // DF 深度优先   栈实现
    function deepCopy_df_stack(param) {
        let res = getEmpty(param)
        let quoteMap = new WeakMap()
        let stacks = []
        if(typeof param == "object"){
            if(quoteMap.has(param)) return quoteMap.get(param)
            quoteMap.set(param, res)
            stacks.push([param, res])
        }else if(typeof param == "function"){
            res = eval('(' + param.toString() + ')')
        }

        while (stacks.length) {
            let [ori, tar] = stacks.pop()       // 先进后出
            for(let key in ori){
                if(quoteMap.get(ori[key])){
                    tar[key] = quoteMap.get(ori[key])
                    continue
                }
                
                tar[key] = getEmpty(ori[key])
                if (typeof ori[key] == "object"){
                    stacks.push(ori[key], tar[key])
                    quoteMap.set(ori[key], tar[key])
                } else if (typeof param == "function") {
                    res = eval('(' + param.toString() + ')')
                }
            }
        }
        return res
    }

    // BF 广度优先   队列实现
    function deepCopy_bf_queue(param) {
        let res = getEmpty(param)
        let quoteMap = new WeakMap()
        let queue = []
        if (typeof param == "object") {
            if (quoteMap.has(param)) return quoteMap.get(param)
            quoteMap.set(param, res)
            queue.push([param, res])           
        } else if (typeof param == "function") {
            res = eval('(' + param.toString() + ')')
        }

        while (queue.length) {
            let [ori, tar] = queue.shift()      // 先进先出
            for (let key in ori) {
                if (quoteMap.get(ori[key])) {
                    tar[key] = quoteMap.get(ori[key])
                    continue
                }

                tar[key] = getEmpty(ori[key])
                if (typeof ori[key] == "object") {
                    queue.push(ori[key], tar[key]) 
                    quoteMap.set(ori[key], tar[key])
                } else if (typeof param == "function") {
                    res = eval('(' + param.toString() + ')')
                }
            }
        }
        return res
    }
```