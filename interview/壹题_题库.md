# 题库
题目在前, 答案在后
    
## 题目

### 第 1 题: 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？
解析: [思路](#第1题:)

### 第 2 题: ['1', '2', '3'].map(parseInt) what & why ?
解析: [思路](#第2题:)

### 第 3 题：什么是防抖和节流？有什么区别？如何实现？
解析: [思路](#第3题:)







## 思路

### 第1题:
考察`diff算法`对数组模板的处理        

tag: [diff算法](http://hcysun.me/vue-design/zh/renderer-diff.html#%E5%87%8F%E5%B0%8Fdom%E6%93%8D%E4%BD%9C%E7%9A%84%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80)

数据模型为数组时, 有/无key的两种不同diff方案
- 无key
    1. 数据位置替换时, `就地复用`原来的子节点, 仅更新被观察的属性
    2. 数据增删时, `就地复用`原来的子节点, 仅更新被观察的属性, 再添加或删除节点
    3. 在简单模板的情况下, 速度较有key会快一点, 因为可以有效复用节点,不用在节点增删上消耗时间.     
- 有key
    1. 数据位置替换时, 根据key找到对应dom, dom节点位置进行交换
    2. 数据增删时, 删除被删掉的dom节点, 重新生成带有新key的dom节点
    3. 可以更准确(根据key对比), 更快速(key可以组成map对象)获取到对应的节点

答案: [详细答案](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1)


### 第2题:
考察`Array.prototype.map` 和 `parseInt`的参数
tag: Array, parseInt, 进制

- Array.prototype.map(callback)
    - callback(currentValue, index, currentArray)
        - currentValue
        - index
        - currentArray

- parseInt(string, radix)   把字符串string当做radix进制的值,  返回string在十进制下的数值
    - string,  被处理的字符串
    - radix,   解析时的基数, 范围: [2, 36]


```javascript
[1,2,3].map(parseInt)       // [1, NaN, NaN]
// 相当于
[
    parseInt(1, 0),         // 1, 基数为0时, string不以"0x"或"0"开头, 则基数为10
    parseInt(2, 1),         // NaN, radix范围不正确, 1不在[2, 36]内
    parseInt(3, 2)          // NaN, 3 不是有效地二进制值
]


// 变式:
let unary = fn => val => fn(val)        // let unary = fn => (val, index) => fn(val, index)
let parse = unary(parseInt)
console.log(['1.1', '2', '0.3'].map(parse))

```
[parseInt方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)


### 第3题:
考察 异步编程, 优化思路, 闭包       
tag: setTimeout, 防抖节流, 闭包

- 防抖: 请求需要在一定时间内不重复触发, 之后才会执行, 如果在这个时间内又发送请求则重新计算时间
- 节流: 请求在一定时间区间内只会执行一次, 
```javascript
// 防抖
function debounce(fn, ms, ...args){
    let timeoutId = 0
    return e => {
        if(timeoutId) clearTimeout(timeoutId)
        // setTimeout 函数内的上下文为window, 所以需要绑定上下文
        timeoutId = setTimeout(() => fn.apply(this, [e, ...args]), ms)  
    }
}

// 节流
function throttle(fn, ms, ...args){
    let time = 0
    return e => {
        if(Date.now() - time < ms) return
        time = Date.now()
        setTimeout(() => fn.apply(this, [e, ...args]), ms) 
    }
}
```