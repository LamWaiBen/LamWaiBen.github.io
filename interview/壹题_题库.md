# 题库
题目在前, 答案在后
    
## 题目

### 第 1 题: 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？
解析: [思路](#第1题:)

### 第 2 题: ['1', '2', '3'].map(parseInt) what & why ?
解析: [思路](#第2题:)

### 第 3 题：什么是防抖和节流？有什么区别？如何实现？
解析: [思路](#第3题:)

### 第 4 题：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？
解析: [思路](#第4题:)

### 第 5 题：介绍下深度优先遍历和广度优先遍历，如何实现？
解析: [思路](#第5题:)

### 第 6 题：请分别用深度优先思想和广度优先思想实现一个拷贝函数？
解析: [思路](#第6题:)

### 第 7 题：ES5/ES6 的继承除了写法以外还有什么区别？
解析: [思路](#第7题:)

### 第 8 题：setTimeout、Promise、Async/Await 的区别
解析: [思路](#第8题:)

### 第 9 题：Async/Await 如何通过同步的方式实现异步
解析: [思路](#第9题:)


### 第 10 题：异步笔试题
> 请写出下面代码的运行结果
```javascript
    async function async1() {
        console.log('async1 start');
        await async2();
        console.log('async1 end');
    }
    async function async2() {
        console.log('async2');
    }
    console.log('script start');
    setTimeout(function() {
        console.log('setTimeout');
    }, 0)
    async1();
    new Promise(function(resolve) {
        console.log('promise1');
        resolve();
    }).then(function() {
        console.log('promise2');
    });
    console.log('script end');
```
解析: [思路](#第10题:)


### 第 11 题：算法手写题
> 已知如下数组：
> 
> var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
> 
> 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组
解析: [思路](#第11题:)


### 第 12 题：JS 异步解决方案的发展历程以及优缺点。
解析: [思路](#第12题:)


### 第 13 题：Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？
解析: [思路](#第13题:)


### 第 14 题：如何实现一个 new 操作符?
解析: [思路](#第14题:)


### 第 15 题：简单讲解一下http2的多路复用
解析: [思路](#第15题:)


### 第 16 题：谈谈你对TCP三次握手和四次挥手的理解
解析: [思路](#第16题:)


### 第 17 题：A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态
> 如果A 与 B 建立了正常连接后，从未相互发过数据，这个时候 B 突然机器重启.
> 问 A 此时处于 TCP 什么状态？如何消除服务器程序中的这个状态？（超纲题，了解即可）
解析: [思路](#第17题:)


### 第 18 题：React 中 setState 什么时候是同步的，什么时候是异步的？
解析: [思路](#第18题:)


### 第 19 题：React setState 笔试题，下面的代码输出什么？
```javascript
    class Example extends React.Component {
        constructor() {
            super();
            this.state = {
                val: 0
            };
        }
        
        componentDidMount() {
            this.setState({val: this.state.val + 1});
            console.log(this.state.val);    // 第 1 次 log

            this.setState({val: this.state.val + 1});
            console.log(this.state.val);    // 第 2 次 log

            setTimeout(() => {
                this.setState({val: this.state.val + 1});
                console.log(this.state.val);  // 第 3 次 log

                this.setState({val: this.state.val + 1});
                console.log(this.state.val);  // 第 4 次 log
            }, 0);
        }

        render() {
            return null;
        }
    };
```
解析: [思路](#第19题:)



### 第 20 题：介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？
解析: [思路](#第20题:)



### 第 21 题：有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣
Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()
解析: [思路](#第21题:)



### 第 22 题：介绍下重绘和回流(重排)（Repaint & Reflow），以及如何进行优化
解析: [思路](#第22题:)


### 第 23 题：介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景
解析: [思路](#第23题:)


### 第 24 题：聊聊 Redux 和 Vuex 的设计思想
解析: [思路](#第24题:)


### 第 25 题：浏览器和Node 事件循环的区别
解析: [思路](#第25题:)


### 第 26 题：介绍模块化发展历程
可从IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、&lt;script type="module"&gt; 这几个角度考虑。
解析: [思路](#第26题:)


### 第 27 题：全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？
解析: [思路](#第27题:)


### 第 28 题：cookie 和 token 都存放在 header 中，为什么不会劫持 token？
解析: [思路](#第28题:)


### 第 29 题：聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的
解析: [思路](#第29题:)


### 第 30 题：两个数组合并成一个数组
请把两个数组 ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'] 和 ['A', 'B', 'C', 'D']，合并为 ['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C', 'D1', 'D2', 'D']。
解析: [思路](#第30题:)


### 第 31 题：改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。
for (var i = 0; i< 10; i++){
	setTimeout(() => {
		console.log(i);
    }, 1000)
}

解析: [思路](#第31题:)


### 第 32 题：Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。
解析: [思路](#第32题:)



### 第 33 题：下面的代码打印什么内容，为什么？
var b = 10;
(function b(){
    b = 20;
    console.log(b); 
})();
解析: [思路](#第33题:)



### 第 34 题：简单改造下面的代码，使之分别打印 10 和 20。
var b = 10;
(function b(){
    b = 20;
    console.log(b); 
})();
解析: [思路](#第34题:)


### 第 35 题：浏览器缓存读取规则
可以分成 Service Worker、Memory Cache、Disk Cache 和 Push Cache，那请求的时候 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache中？
解析: [思路](#第35题:)


### 第 36 题：使用迭代的方式实现 flatten 函数。
解析: [思路](#第36题:)


### 第 37 题：为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？
解析: [思路](#第37题:)


### 第 38 题：下面代码中 a 在什么情况下会打印 1？
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}
公司：京东
解析: [思路](#第38题:)


### 第 39 题：介绍下 BFC 及其应用.
解析: [思路](#第39题:)


### 第 40 题：在 Vue 中，子组件为何不可以修改父组件传递的 Prop
如果修改了，Vue 是如何监控到属性的修改并给出警告的。
解析: [思路](#第40题:)


### 第 41 题：下面代码输出什么
var a = 10;
(function () {
    console.log(a)
    a = 5
    console.log(window.a)
    var a = 20;
    console.log(a)
})()
解析: [思路](#第41题:)


### 第 42 题：实现一个 sleep 函数
比如 sleep(1000) 意味着等待1000毫秒，可从 Promise、Generator、Async/Await 等角度实现
解析: [思路](#第42题:)


### 第 43 题：使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果
解析: [思路](#第43题:)


### 第 44 题：介绍 HTTPS 握手过程
解析: [思路](#第44题:)


### 第 45 题：HTTPS 握手过程中，客户端如何验证证书的合法性
解析: [思路](#第45题:)




### 第 46 题：输出以下代码执行的结果并解释为什么
var obj = {
    '2': 3,
    '3': 4,
    'length': 2,
    'splice': Array.prototype.splice,
    'slice': Array.prototype.slice,
    'push': Array.prototype.push
}
obj.push(1)
obj.push(2)
console.log(obj)
解析: [思路](#第46题:)


### 第 47 题：双向绑定和 vuex 是否冲突
解析: [思路](#第47题:)


### 第 48 题：call 和 apply 的区别是什么，哪个性能更好一些
解析: [思路](#第48题:)


### 第 49 题：为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？
解析: [思路](#第49题:)


### 第 50 题：实现 (5).add(3).minus(2) 功能。
例： 5 + 3 - 2，结果为 6
解析: [思路](#第50题:)


### 第 51 题：Vue 的响应式原理中 Object.defineProperty 有什么缺陷？
为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？
解析: [思路](#第51题:)


### 第 52 题：怎么让一个 div 水平垂直居中?
解析: [思路](#第52题:)


### 第 53 题：输出以下代码的执行结果并解释为什么
var a = {n: 1};
var b = a;
a.x = a = {n: 2};

console.log(a.x) 	
console.log(b.x)
解析: [思路](#第53题:)


### 第 54 题：冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？
解析: [思路](#第54题:)


### 第 55 题：某公司 1 到 12 月份的销售额存在一个对象里面
如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。
解析: [思路](#第55题:)


### 第 56 题：要求设计 LazyMan 类，实现以下功能。
LazyMan('Tony');
// Hi I am Tony

LazyMan('Tony').sleep(10).eat('lunch');
// Hi I am Tony
// 等待了10秒...
// I am eating lunch

LazyMan('Tony').eat('lunch').sleep(10).eat('dinner');
// Hi I am Tony
// I am eating lunch
// 等待了10秒...
// I am eating diner

LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food
解析: [思路](#第56题:)


### 第 57 题：分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。
解析: [思路](#第57题:)


### 第 58 题：箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？
解析: [思路](#第58题:)


### 第 59 题：给定两个数组，写一个方法来计算它们的交集。
例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。
解析: [思路](#第59题:)


### 第 60 题：已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。
&lt;img src="1.jpg" style="width:480px!important;”&gt;
解析: [思路](#第60题:)


### 第 61 题：介绍下如何实现 token 加密
解析: [思路](#第61题:)


### 第 62 题：redux 为什么要把 reducer 设计成纯函数
解析: [思路](#第62题:)


### 第 63 题：如何设计实现无缝轮播
解析: [思路](#第63题:)


### 第 64 题：模拟实现一个 Promise.finally
解析: [思路](#第64题:)


### 第 65 题： a.b.c.d 和 a['b']['c']['d']，哪个性能更高？
解析: [思路](#第65题:)


### 第 66 题：ES6 代码转成 ES5 代码的实现思路是什么
解析: [思路](#第66题:)


### 第 67 题：数组编程题
随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]。
解析: [思路](#第67题:)


### 第 68 题： 如何解决移动端 Retina 屏 1px 像素问题
解析: [思路](#第68题:)


### 第 69 题： 如何把一个字符串的大小写取反?
解析: [思路](#第69题:)


### 第 70 题： 介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的
解析: [思路](#第70题:)


### 第 71 题： 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。
解析: [思路](#第71题:)


### 第 72 题：为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因.
解析: [思路](#第72题:)


### 第 73 题： 介绍下 BFC、IFC、GFC 和 FFC
解析: [思路](#第73题:)



### 第 111 题：编程题，写个程序把 entry 转换成如下对象:
```javascript
var entry = {
    a: {
        b: {
            c: {
                dd: 'abcdd'
            }
        },
        d: {
            xx: 'adxx'
        },
        e: 'ae'
    }
}

// 要求转换成如下对象
var output = {
'a.b.c.dd': 'abcdd',
'a.d.xx': 'adxx',
'a.e': 'ae'
}
```
解析: [思路](#第111题:)


### 第 114 题：找出字符串中连续出现最多的字符和个数
```
'abcaakjbb' => {'a':2,'b':2}
'abbkejsbcccwqaa' => {'c':3}
注意：题目说的是连续出现，注意连续二字
```
解析: [思路](#第114题:)


### 第 152 题：实现一个 normalize 函数，能将输入的特定的字符串转化为特定的结构化数据
```
字符串仅由小写字母和 [] 组成，且字符串不会包含多余的空格。
示例一: 'abc' --> {value: 'abc'}
示例二：'[abc[bcd[def]]]' --> {value: 'abc', children: {value: 'bcd', children: {value: 'def'}}}
```
解析: [思路](#第152题:)

### 第 158 题：如何模拟实现 Array.prototype.splice
解析: [思路](#第158题:)

































----------------------------









## 思路

### 第1题:
考察`diff算法`对数组模板的处理        

tag: [diff算法](http://hcysun.me/vue-design/zh/renderer-diff.html#%E5%87%8F%E5%B0%8Fdom%E6%93%8D%E4%BD%9C%E7%9A%84%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80)

数据模型为数组时, 有/无key的两种不同diff方案
- 无key
    1. 数据位置替换时, `就地复用`原来的子节点, 仅更新被观察的属性
    2. 数据增删时, `就地复用`原来的子节点, 仅更新被观察的属性, 再添加或删除节点
    3. 在简单模板的情况下, 速度较有key会快一点, 因为可以有效复用节点,不用在节点增删上消耗时间.     
- 有key
    1. 数据位置替换时, 根据key找到对应dom, dom节点位置进行交换
    2. 数据增删时, 删除被删掉的dom节点, 重新生成带有新key的dom节点(不会采取就地复用的方案, 避免之前节点的状态被保留下来而产生的bug)
    3. 可以更准确(根据key对比, 不存在就地复用时导致的状态不一致问题), 更快速(key可以组成map对象)获取到对应的节点

答案: [详细答案](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1)


### 第2题:
考察`Array.prototype.map` 和 `parseInt`的参数
tag: Array, parseInt, 进制

- Array.prototype.map(callback)
    - callback(currentValue, index, currentArray)
        - currentValue
        - index
        - currentArray

- parseInt(string, radix)   把字符串string当做radix进制的值,  返回string在十进制下的数值
    - string,  被处理的字符串
    - radix,   解析时的基数, 范围: [2, 36]


```javascript
[1,2,3].map(parseInt)       // [1, NaN, NaN]
// 相当于
[
    parseInt(1, 0),         // 1, 基数为0时, string不以"0x"或"0"开头, 则基数为10
    parseInt(2, 1),         // NaN, radix范围不正确, 1不在[2, 36]内
    parseInt(3, 2)          // NaN, 3 不是有效地二进制值
]


// 变式:
let unary = fn => val => fn(val)        // let unary = fn => (val, index) => fn(val, index)
let parse = unary(parseInt)
console.log(['1.1', '2', '0.3'].map(parse))

```
[parseInt方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)


### 第3题:
考察 异步编程, 优化思路, 闭包       
tag: setTimeout, 防抖节流, 闭包

- 防抖: 请求需要在一定时间内不重复触发, 之后才会执行, 如果在这个时间内又发送请求则重新计算时间
- 节流: 请求在一定时间区间内只会执行一次, 
```javascript
// 防抖
function debounce(fn, ms, ...args){
    let timeoutId = 0
    return e => {
        if(timeoutId) clearTimeout(timeoutId)
        // setTimeout 函数内的上下文为window, 所以需要绑定上下文
        timeoutId = setTimeout(() => fn.apply(this, [e, ...args]), ms)  
    }
}

// 节流
function throttle(fn, ms, ...args){
    let time = 0
    return e => {
        if(Date.now() - time < ms) return
        time = Date.now()
        setTimeout(() => fn.apply(this, [e, ...args]), ms) 
    }
}
```


### 第4题:
考察 ES6        

- Set: 成员不重复的类似数组的数据结构
- Map: 可以以任意值(包括引用类型的值))为key的数据结构
- WeakSet: `成员只能是对象且对成员的引用为弱引用`, 不计入引用次数, 成员可以被回收,  不能遍历不能清空
- WeakMap: 与Map不同的点是, `key只能是对象且对key的引用为弱引用`, 不计入引用次数, key可以被回收, 不能遍历不能清空

共同特点:         
1. 无法直接与JSON相互转换    
    

### 第5题:
考察 算法, DFS, BFS

- 深度优先遍历(DFS)      
    1. 从根节点起,选择某一个分支, 一直往子分支迭代,直到尽头再重新回到路线最初的分叉点从新开始迭代另一分支
    2. 可以用`递归`或`栈`实现
- 广度优先遍历(BFS)      
    1. 从根节点起, 先迭代同一层级的子分支, 然后再迭代子分支的子分支(孙代分支).
    2. 可以用`队列`实现

```javascript
// 假设节点都在children数组中

// 深度优先遍历(DFS)      递归
function dfs(node, nodeList = []){
    if(node){
        nodeList.push(node)
        let children = node.children
        for(let v of children){
            dfs(v, nodeList)
        }
    }
    return nodeList
}

// 广度优先遍历(BFS)      队列
function bfs(node){
    let nodes = []
    let stacks = []
    if(node){
        stacks.push(node)
        while (stacks.length) {
            node = stacks.shift()
            nodes.push(node)
            for(let childNode of node.children){
                stacks.push(childNode)
            }
        }
    }
    return nodes
}

```


### 第6题:
考察 拷贝函数, DFS, BFS
- 深拷贝函数, 需要注意的点:
    - Object
        - object
        - array
        - Map/Set
        - 其他类型及其原型链(Date, RegExp...)
    - Symbol
    - function
    - 内部引用的处理
```javascript
    function getEmpty(o) {
        let constructor = o.constructor
        if(constructor == Object) return {}
        else if(constructor == Array) return []
        else if(constructor == Date) return new Date(o)
        else if(constructor == RegExp) return new RegExp(o)
        else if(constructor == Map) return new Map(o)       // 浅复制
        else if(constructor == Set) return new Set(o)       // 浅复制
        return o;
    }

    // DF 深度优先   栈实现
    function deepCopy_df_stack(param) {
        let res = getEmpty(param)
        let quoteMap = new WeakMap()
        let stacks = []
        if(typeof param == "object"){
            if(quoteMap.has(param)) return quoteMap.get(param)
            quoteMap.set(param, res)
            stacks.push([param, res])
        }else if(typeof param == "function"){
            res = eval('(' + param.toString() + ')')
        }

        while (stacks.length) {
            let [ori, tar] = stacks.pop()       // 先进后出
            for(let key in ori){
                if(quoteMap.get(ori[key])){
                    tar[key] = quoteMap.get(ori[key])
                    continue
                }
                
                tar[key] = getEmpty(ori[key])
                if (typeof ori[key] == "object"){
                    stacks.push(ori[key], tar[key])
                    quoteMap.set(ori[key], tar[key])
                } else if (typeof param == "function") {
                    res = eval('(' + param.toString() + ')')
                }
            }
        }
        return res
    }

    // BF 广度优先   队列实现
    function deepCopy_bf_queue(param) {
        let res = getEmpty(param)
        let quoteMap = new WeakMap()
        let queue = []
        if (typeof param == "object") {
            if (quoteMap.has(param)) return quoteMap.get(param)
            quoteMap.set(param, res)
            queue.push([param, res])           
        } else if (typeof param == "function") {
            res = eval('(' + param.toString() + ')')
        }

        while (queue.length) {
            let [ori, tar] = queue.shift()      // 先进先出
            for (let key in ori) {
                if (quoteMap.get(ori[key])) {
                    tar[key] = quoteMap.get(ori[key])
                    continue
                }

                tar[key] = getEmpty(ori[key])
                if (typeof ori[key] == "object") {
                    queue.push(ori[key], tar[key]) 
                    quoteMap.set(ori[key], tar[key])
                } else if (typeof param == "function") {
                    res = eval('(' + param.toString() + ')')
                }
            }
        }
        return res
    }
```


### 第7题:
考察 ES6, Class, 继承, 原型

- ES5继承
    - 原型链继承  
        - 将一个父类的实例赋值给子类的构造函数的原型。
        - 实例的constructor依然指向父类的构造函数
        - 所有实例都共享同一个父类原型, 修改原型上的引用属性会影响所有子类
    - 构造函数继承  
        - 在子类的构造函数内部调用父类构造函数, 通过使用apply或call方法调用可以在子类实例化的时候执行父类构造函数
        - 可以传递属性, 父类的属性会设置在子类上
        - 父类中定义的方法子类实例无法调用, 同样的方法都要在子类上写一遍
    - 组合式继承  
        - 既使用原型链实现对原型属性和方法的继承，用借用构造函数模式实现对实例属性的继承.
        - 原型上定义的方法可以复用, 每个实例也都有自己的属性
        - 需要调用两次父类构造函数
    - 原型式继承
        - 改造`原型链继承`, 不使用父类的构造函数创建实例, 使用父类的原型创建新的对象作为子类实例
        - Object.create(proptotype, childObj)
        - 与`原型链继承`有一样的缺点, 修改父类原型上的引用属性会影响所有子类
    - 寄生式继承
        - 在`原型式继承`的基础上为对象添加函数, 增强对象
        - 无法函数复用, 与`构造函数继承`类似
    - 寄生组合式继承
        - `寄生式继承`和`组合式继承`的结合, 借助`构造函数`继承属性, 又用过`原型链`继承方法
        - 与`组合式继承`的主要区别在于 前者原型使用的是父类的一个副本, 后者直接使用父类的实例作为原型
        - 只调用一次父类构造函数, 子类原型上不需要创建多余的属性, 原型链可以保持不变, 可以正常使用instanceof isPrototypeOf 方法.
- class
    - `寄生组合式继承`的语法糖
    - class之间使用`extends`关键字继承, 子类的constructor中必须调用super方法猴才能使用this, 因为子类没有自己的this对象,而是继承父类的this对象
- 区别点
    1. `class` 声明会提升, 但是不会赋值, 会进入暂时性死区(TDZ), 类似于`let`, `const`
    2. `class` 内部会启用严格模式
    3. `class` 所有方法都是不可枚举的, 也没有原型对象,所以无法使用`new`来调用
    4. `class` 内部无法重写类名。
```javascript
    //寄生组合式继承
    function inheritPrototype(subType, superType){
        let prototype = Object.create(superType)    // 创建副本对象
        prototype.constructor = subType             // 增加对象, 改变构造函数的指向
        subType.prototype = prototype               // 指向原型
    }

    function superType(name){
        this.name = name
        this.colors = ["red", "green", "blue"]
    }
    superType.prototype.sayName = function (){
        console.log(this.name)
    }

    function subType(name, age){
        superType.call(this, name)          // 继承属性
        this.age = age
    }
    
    inheritPrototype(subType, superType)    // 继承方法
    subType.prototype.sayAge = function(){
        console.log(this.age)
    }


    // ES6
    class SuperType{}
    class SubType extends SuperType{}
    SubType.__proto__ === SuperType                         //true, 继承属性
    SubType.prototype.__proto__ === SuperType.prototype     //true, 继承方法

    // 因为 
    // SubType.prototype.__proto__ === SuperType.prototype 
    // sub.__proto__ == SubType.prototype 
    // 所以
    let sub = new SubType()
    sub.__proto__.__proto__ === SuperType.prototype         // true
```
![图片](../pic/ES6_class.png)


### 第8题:
考察 异步, EventLoop
- macrotask queue
    - 宏任务队列: 本质是浏览器多个线程之间通信的一个消息队列, 可能会有多个宏队列
    - 属于宏任务的有: setTimeout, setInterval, setImmediate, requestAnimationFrame
- microtask queue
    - 微任务队列: 只有一个队列, `每执行一个宏任务后`,都会执行为任务队列中的所有任务内容
    - 属于微任务的有: MutationObserver, promise的回调, process.nextTick


### 第9题:
考察 async/await, generator

- 借助ES6的`generator`函数, 包装了`yield`操作符与`next`方法, 使其看起来像是同步的代码
- 基本原理如下: [bAsync](../code/doOneself/bAsync/bAsync.js)



### 第10题:
考察 EventLoop, 异步

```
----------------- macrotask 开始
script start
async1 start
async2
promise1
script end
----------------- macrotask 结束
----------------- microtask 开始
async1 end
promise2
----------------- microtask 结束
----------------- macrotask 开始
setTimeout
----------------- macrotask 结束
```
[变式-举一反三](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7)



### 第11题:
考察 数组去重
```javascript

var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
//编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

// 借组对象
function flagSort(arr, obj = {}){
    for(let v of arr){
        if(Array.isArray(v)) flag(v, obj)
        else obj[v] = null
    }
    return Object.keys(obj).map(v => ~~v).sort((a, b) => a - b)
}

// 借助 Set 和 flag
function flag_native(arr){
    return [...new Set(arr.flat(Infinity))].sort((a, b) => a - b)
}

// 使用reduce 和concat 模拟 flag
function arrayFlag(arr){
    return arr.reduce((acc, val) => {
        if(Object.prototype.toString.call(val) == "[object Array]"){
            console.log(acc)
            return acc.concat(arrayFlag(val))   // 需要return 数组
        }else{
            console.log(acc)
            return acc.concat(val)              // 需要return 数组
        }
    }, [])
}

```


### 第12题:
考察: 异步解决方案有几种

- 回调: 通过传递回调函数, 响应时执行回调函数
    - 优点: 简单解决了同步的问题
    - 缺点: 回调地狱(反人类思维, 耦合度高, 难以处理错误), 不能捕获错误, 不能return

- Promise: ES6的Promise语法
    - 优点: 可以避免回调嵌套
    - 缺点: 无法取消Promise

- Async/Await: ES7的语法, 基于Promise和Generator
    - 优点: 可以用同步风格的语法来写异步代码
    - 缺点: 无关联的异步函数, 用同步的语法来写会导致性能下降



### 第13题:
考察: promise  

构造函数是同步执行的, then是异步的microTask, 在当前任务完成的时候执行.



### 第14题:
考察: new操作符 构造函数  

```javascript
// new 做了什么?
// 1. 创建一个空对象
// 2. 空对象连接构造函数的原型
// 3. 构造函数参数传递, 将this指向新对象
function _new(conFn, ...args){
    const obj = Object.create(conFn.prototype)
    const ret = conFn.apply(obj, args)
    return ret instanceof conFn ? ret : obj     // 判断 Date, regexp, Array 之类的构造函数返回值 
}

```

### 第15题:
考察: HTTP2 多路复用  

1. HTTP2的特点: 二进制协议, 多工, 数据流, 头信息压缩, 服务器推送
2. 什么是多路复用? 连接不会断开, 而且支持同时发送多个请求, 顺序可以不一一对应, 且不会阻塞
3. 实现原理? HTTP2的数据流都必须标记数据ID, 根据数据ID 可以找到对应的请求/响应值, 所以支持多路复用
4. 与HTTP1.1的 `Keep Alive` 有什么区别? 在Keep Alive的基础上增加了多路复用的功能, 而且HTTP2还支持头信息压缩, 服务器推送


### 第16题:
考察: TCP 三次握手四次挥手  
- A为客户端 , B为服务端
- 建立连接: A发送请求(SYN) --> B响应返回(SYN/ACK) -->  A接收后发送(ACK)  

- 断开连接: A发送请求(FIN) --> B响应返回(ACK) --> B做好关闭准备发送(FIN) --> A接收后发送(ACK)           


### 第17题:
考察: TCP   

- 从未相互发过数据: ESTABLISHED 
- 已发过数据: ESTABLISHED
- B端重启, A端状态: TCP没有正常关闭, 超时后, A端会发送FIN 断开请求等待回复的状态, FIN WAIT
- 如何消除A端的状态?


### 第18题:
考察: React  State


这里的异步/同步指的是: 调用setState后, 数据是否立即更新.
- 异步(调用后不会立即就触发更新)  
    由React控制的事件处理函数以及生命周期函数中调用setState不会立即更新的
- 同步(调用后立即触发更新)  
    React控制之外的事件中调用setState是立即更新的,   
    如: js原生绑定事件(addEventListener), setTimeout之类的


### 第19题:
考察: React State   

与18题相似考察React State的更新时机,
``` javascript
// 在react自身生命周期内, 触发时 isBatchingUpdates 为 true
componentDidMount() {
    this.setState({val: this.state.val + 1});               //  val 为 0
    console.log(this.state.val);    // 第 1 次 log              

    this.setState({val: this.state.val + 1});               //  val 为 0
    console.log(this.state.val);    // 第 2 次 log

    setTimeout(() => {
        // 由于前两个state会合并更新,  所以在setTimeou回调触发时, val 为 1
        // isBatchingUpdates 为false,  会立即更新 this.state

        this.setState({val: this.state.val + 1});          //  val 为  2
        console.log(this.state.val);  // 第 3 次 log

        this.setState({val: this.state.val + 1});          //  val 为  3
        console.log(this.state.val);  // 第 4 次 log
    }, 0);
}

// 0 , 0, 2, 3
```


### 第20题:
考察: npm  

npm 模块安装机制
1. 查找依赖的模块: 起始查找文件优先级:  package-lock.json > package.json.  
    根据各个模块的自身的依赖, 可以生成一颗依赖树
2. 确定模块版本: 根据 @(当前版本) 和 ^(向上匹配) 标识符,假如不同的模块都对A模块有依赖
    - 可以找到兼容版本时, 则把这依赖树拍平到根节点, 只需要安装一个版本的A模块就可以
    - 如果找不到兼容版本, 则维持原来的依赖树, 需要安装不同版本的A模块
3. 安装下载: 先从全局缓存中查找, 若找不到则从仓库下载



### 第21题:
考察: Array, 原型判断  

- Object.prototype.toString.call()
    1. 输出对象的内部标签, "[Object Array]"
    2. 可以通过修改对象A的`Symbol.toStringTag`属性来改变结果
- instanceof
    1. A instanceof B , 判断A的原型链中是否包含构造函数B的原型对象
    2. 可以通过修对象A的`Symbol.hasInstance`属性来改变结果
    3. 无法判断来自`iframe`的Array, 因为跟`windows`的Array并非同一个函数, 所以原型对象也不一样
- Array.isArray()
    1. ES5加入的, 最准确的判断方法
    2. 不兼容时需要 Polyfill


### 第22题:
考察: 浏览器渲染 重绘 回流(重排)  

- 浏览器渲染过程
    1. 解析HTML, 生成DOM树; 解析CSS, 生成CSSOM树
    2. 结合DOM树和CSSOM树, 生成渲染树
    3. 进行Layout(重排), 得到各个节点的几何信息(位置, 大小)
    4. Paintin(重绘), 根据渲染树以及重排的几何信息, 得到节点的绝对像素
    5. Display(展示), 把像素发送给GPU, 展示页面.
- 重绘
    1. 页面布局不变化, 仅元素内部分不影响布局的属性调整, 重新绘制元素
- 重排
    1. 布局发生变化, 重排必定导致重绘

- 优化
    1. 避免触发同步布局事件, 减少使用会导致立即重排的属性(offsetTop, offsetLeft, offsetWidth, scrollTop, scrollLeft, clientTop..等)都会立即刷新渲染队列
    2. 使用`class`和`cssText`的方式合并多次对DOM和样式的修改
    3. 脱离文档修改元素: 1.使元素脱离文档流(隐藏/移除; 拷贝生成一个新节点); 2. 修改样式; 3.把元素带回文档流
    4. 复杂动画, 使用绝对定位脱离文档流
    5. CSS3硬件加速, 使部分动画属性不引起重排重绘


- [答案](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24)


### 第23题:
考察: 设计模式, 订阅-发布模式, 观察者模式 

- 订阅-发布模式
    - 区别: 有事件调度中心, 订阅者和发布者只需要通过调度中心来交流, 不需要知道对方是谁, 调度中心只需要调用订阅者提供的回调.
    - 用途: 1个调度中心对应多个订阅者发布者, 类似于报社,邮局,个人的关系.
- 观察者模式
    - 区别: 发布者和订阅者都需要知道对方的存在, 直接调用订阅者上的方法
    - 用途: 1对1直接沟通, 类似于个体奶农和个人的直接沟通关系.


### 第24题:
考察: Redux, Vuex

- Redux
    1. 通过纯函数生成新的state
    2. 为了保证每次状态变化都能跟踪, 需要强制immutability, 每次都要生成新的state
    3. 异步需要用chunk中间件
    4. 与之相似的状态管理思想: Flux
- Vuex
    1. 通过commit("method")的方式修改store
    2. 有getter, 方便计算属性复用
    3. 可以直接挂载到根节点, 方便引用
    4. 异步可以使用dispatch(action)的方式,处理完异步后,最终commit(action)
    5. 与之相似的状态管理思想: Mobx
- 设计思想
    0. 全局state保存状态
    1. 单向数据流
    2. state的修改必须是同步的, 否则无法确认修改方法的调用顺序

[Vuex、Flux、Redux、Redux-saga、Dva、MobX的设计思路](https://zhuanlan.zhihu.com/p/53599723)



### 第25题:
考察: EventLoop  

有3种任务队列: macroTask, microTask, nextTick(node独有)
- 浏览器执行顺序:  
    每执行一个macroTask, 都会去执行microTaskQueue, 然后再继续执行剩余的macroTaskQueue
- node11之前:  
    执行完同一个macroTaskQueue中所有任务, 再执行nextTick, 最后执行microTaskQueue
- node11之后:  
    顺序几乎与浏览器保持一致, 每执行一个macroTask,先执行nextTick, 然后再会去执行microTaskQueue, 然后再继续执行剩余的macroTaskQueue


### 第26题:
考察: 模块化

模块化的主要作用是为了抽离公共代码, 隔离作用域, 避免变量冲突.

- IIFE  
    自执行函数, 避免变量冲突

- AMD  
    1. 使用范围: 浏览器
    2. requireJS实现的 
        ```javascript
            define(['module1', 'module2'], (m1, m2) => {
                const newModule = {}
                return newModule
            })
        ```
    3. 特点: 依赖必须提前声明好
- CMD
    1. 使用范围: 浏览器
    2. seaJS实现的
        ```javascript
            define(function(require, exports, module){
                var code = require('./index.js')
                var asyncCode = require.async('./async.js', code => {})
            })
        ```
    3. 特点: 整合, 支持动态引入的依赖文件
- CommonJS  
    1. 使用范围: nodejs, webpack,  
    2. nodejs中自带的模块化, 
    3. 特点: 运行时加载, 返回一个对象

- UMD  
    1. 使用范围:
    2. 语法:
    3. 特点: 兼容AMD, CommonJS的模块化语法

- webpack
    1. 使用范围: 浏览器
    2. 语法:    
        ```javascript
            // method1
            require.ensure()
            // method2
            import().then(code => {})
        ```
    3. 特点: 支持代码切割加载

- ES Module
    1. 使用范围: ES6语法
    2. 语法: import / export
    3. 特点: `静态`加载阶段的引用, ES6模块不是对象, 是对外的一种静态定义

- &lt;script type="module"&gt;
    1. 使用范围: HTML5
    2. 语法参考: [script标签](../note/HTML/Script标签/index.html)




### 第27题:
考察: ES6, 块级作用域  

在ES6的用`let, const`声明的全局变量, 并不属于顶层对象的属性. 因为它其实是在一个全局的块级作用域下, 而并非像ES5中的`var, function`声明在顶层对象里.


### 第28题:
考察: HTTP, cookie, token, CSRF  

- cookie
    1. cookie是请求的时候, 浏览器自动设置到header上的, 可以通过固定的方法去获取它, 容易被CSRF攻击
    2. 不防XSS攻击
- token
    1. token是通过具体的代码人为设置到header上的, 相对没那么容易获取它, 防止CSRF
    2. 不防XSS攻击

- 补充:

    XSS: 是一种攻击者通过留言插入恶意JS脚本在dom中, 从而收集用户私隐, 持劫用户等, 利用用户对指定网站的信任(`DOM中携带的JS脚本也可以运行的特性`).

    XSS的方法有两种:
    1. 验证所有`输入`数据，有效检测攻击
    2. 对所有`输出`数据进行适当的编码，以防止任何已成功注入的脚本在浏览器端运行

    ----------------------------
    CSRF:  是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法, 利用网站对用户浏览器的信任(`请求会自动携带cookie这个特性`).

    CSRF防范措施主要有两个:
    1. 服务端检验请求头的 `Referer` 字段, 判断请求来源地址是否正确, 但是请求头依然有可能被人为修改
    2. 添加校验token, 在关键请求中加入一个不保存在cookie的token参数, 用于校验请求是否为本人处于自己意愿发送.

### 第29题:
考察: Vue, 双向数据绑定  

利用ES5的`Object.defineProperty` 劫持属性的`getter/setter`, 当数据发生变化时, 触发所有依赖改属性的方法


### 第30题:
考察: 数组, 算法

- 方法1: 合并后, 再排序
    ```javascript
    arr1.concat(arr2).sort((a, b) => {
        let codeA = a.codePointAt(0)
        let codeB = b.codePointAt(0)
        return codeA - codeB
    })
    ```
- 方法2: 统一形式再合并排序, 通用性更强
    ```javascript
        let a1 =  ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']
        let a2 = ['A', 'B', 'C', 'D'].map((item) => {
        return item + 3
        })

        let a3 = [...a1, ...a2].sort().map((item) => {
        if(item.includes('3')){
            return item.split('')[0]
        }
        return item
        })
    ```


### 第31题:
考察: 闭包

```javascript
// 1
for (let i = 0; i< 10; i++){
	setTimeout(() => {
		console.log(i);
    }, 1000)
}
// 2
for (var i = 0; i< 10; i++){
	setTimeout(i => {
		console.log(i);
    }, 1000, i)
}
// 3
for (var i = 0; i< 10; i++){
	(i => setTimeout(() => {
		console.log(i);
    }, 1000))(i)
}

```

### 第32题:
考察: Virtual DOM  

Virtual DOM并没有比原生DOM快, 原因如下:
1. Virtual DOM 需要进行`diff`运算, 而且是在直接操作原生DOM的基础上再封装的
2. Virtual DOM的性能消耗: render Virtual DOM + diff O(template size) + 必要的DOM更新 O(DOM change)
3. 比MVVM快的原因主要是: DOM元素的复用


[尤大大的回答](https://www.zhihu.com/question/31809713/answer/53544875)


### 第33题:
考察: IIFE特性  

会输出`b函数`  
IIFE的函数名是常量, 不可修改  
原因是:  
内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20, 发现了具名函数 function b(){}，拿此b做赋值  
在赋值的时候发现 IIFE的函数无法进行赋值, 类似于const定义的变量  
所以 在普通模式下会静默失败, 在严格模式下会报错.    
但是如果如果在函数内部声明b变量, 这时候可以正常使用b变量


### 第34题:
考察: IIFE特性

1. 输出 10:
    ```javascript
    var b = 10;
    (function b(){
        b = 20;
        console.log(window.b); 
    })();

    ```
2. 输出 20:
    ```javascript
    var b = 10;
    (function b(){
        var b = 20;
        console.log(b); 
    })();

    ```

### 第35题:
考察: 浏览器缓存  

- Service Worker: 浏览器关闭时缓存清空
- Memory Cache: 标签关闭时缓存清空
- Disk Cache: 根据Header字段(Expires; Cache-Control; Last-Modified; ETag等字段)的控制缓存时间
- Push Cache: 只在HTTP/2会话中存在, 会话结束后缓存清空

参考: [缓存机制](../note/浏览器/缓存机制.md)


### 第36题:
考察: flatten  


```javascript
var arr=[1,2,3,[4,5],[6,[7,[8]]]]
function flatten(source) {
    // 迭代实现
    while(source.some(v => Array.isArray(v))){
        source = [].concat(...source)
    }
    return source

    // 递归实现
    return source.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), [])
}

```


### 第37题: 
考察: redux, vuex  
- 0. 因为异步操作存在副作用(成功/失败以及返回的先后顺序), 异步操作是不确定的,不可追踪的
- 1. reducer必须是纯函数,  可以通过中间件组装异步方法, 使用dispatch(action)实现异步
- 2. vuxe中mutation不能使用异步操作, 可以在actions中使用, 通过commit(mutationAction)实现异步


### 第38题:
考察: ToNumber, 隐式转换     

```javascript
// 隐式转换优先级 toPrimitive > valueOf > toString
var a = {
    i: 0,
    [Symbol.toPrimitive] () { return ++a.i },
    valueOf () { return ++a.i },
    toString () { return ++a.i },
};
if (a == 1 && a == 2 && a == 3) {
    console.log(1);
}

// 利用数组特性
var a = [1, 2, 3]
a.join = a.shift
```


### 第39题:
考察: BFC  
BFC: 块级格式上下文, 一个BFC相当于一个独立容器,里面的元素与外部元素互不影响

应用:   
- 同一个BFC下外边距会发送折叠
- BFC可以包含浮动的子元素(清除浮动)
- BFC可以阻止自己的元素被与BFC同一层的浮动元素覆盖(消除文字环绕效果)  



### 第40题:
考察: Vue  

- 为什么? 
    1. 单向数据流, 便于跟踪/维护数据变化.
- 如何监控? 
    1. 传入的props只有是基本数据类型时, 才会发出警告, 而且修改不成功
    2. 在传递prop之后, 用setter包裹prop, 如果不是根节点组件 也不是更新子组件时, 在setter中修改值的时候, 就会触发警告 
    3. 实现原理, 对prop对象重新用Object.defineProperty包裹一次
- 如何正确的修改? 
    1. 在子组件中委托父组件修改


### 第41题:
考察: 变量提升  
```javascript
// 输出:
undefined
10
20
```

### 第42题:
考察: 异步流程, Async的机制

```javascript

// Promise
var sleepByPromise = ms => {
    return new Promise(resolve => setTimeout(resolve, ms))
}
sleepByPromise(1000).then(() => console.log("睡醒啦"))

// Generator
var sleepByGenerator = function*(ms) {
    return yield new Promise(resolve => setTimeout(resolve, ms))
}
sleepByGenerator(1000).next().value.then(() => console.log("睡醒啦"))

// Async/Await
var sleepByAsync = async ms => {
    await new Promise(resolve => setTimeout(resolve, ms))
}
sleepByAsync(1000).then(() => console.log("睡醒啦"))

```

### 第43题:
考察: 原生sort  

> [102, 15, 22, 29, 3, 8] 
> 把每个元素转换成字符串, 根据每个字符的Unicode(UTF-16)顺序排序, 返回值小于0时 升序


### 第44题:
考察: HTTPS, SSL/TLS协议, 数字证书   
开始加密通信之前, SSL/TLS协议做了下面的事情:
1. 客户端给出协议版本号, 随机数1(Client random), 以及支持的加密方法
2. 服务端确认双方的加密方法,并给出数字证书(内含公钥), 以及服务器随机生成的随机数2(Server random)
3. 客户端确认数字证书有效后, 生成一个随机数3(Premaster secret)并使用数字证书中的公钥对其加密, 随后发给服务端(RSA不对称加密)
4. 服务端使用私钥, 解密客户端发来的随机数3
5. 客户端和服务端根据约定的加密方法, 使用前面的三个随机数, 生成对话密钥(session key), 用来对称加密接下来的整个对话过程

[SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)


### 第45题:
考察: 数字证书  

验证步骤:
1. 基本信息: 校验证书所有者和网站域名是否与当前一致, 证书是否在有效期内.
2. 找到CA机构: 查找操作系统内置的证书发布机构CA, 校验证书是否为合法机构颁发的, 若找不到则提示证书不可信
3. 验证hash: 如果可以找到则使用CA机构公开的密钥, 对证书签名解密, 计算该证书的hash值是否一致


### 第46题:
考察: Array.push, 类数组  

引用 MDN[Array.prototype.push](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push) 的解释
> push 方法具有通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。  
> push 方法根据 length 属性来决定从哪里开始插入给定的值。  
> 如果 length 不能被转成一个数值，则插入的元素索引为 0，包括 length 不存在时。当 length 不存在时，将会创建它。

所以将会打印: 
``` javascript
// obj
console.log(obj) //  [empty × 2, 1, 2, splice: ƒ, slice: ƒ, push: ƒ] length: 4

// slice不传参数时, 默认使用length作为参数
obj.slice()     // [empty x 2, 1, 2]
```


### 第47题:
考察: Vue, Vuex  

Vuex是单向数据流的, 所以会冲突. state的值只能通过mutation修改.  
在双向数据绑定的v-model中是无法直接修改state的.   
只能通过绑定事件或借助计算属性, 在函数里面调用commit(action), 达到间接修改state的效果


### 第48题:
考察: call, apply  
- 参数不一样: 除了第一个参数一样外, call的参数需要逐个列出, apply的参数放在数组中
- call的性能比较好, 可以通过`jsPerf`测出


### 第49题:
考察: 埋点  
- 怎么埋点
    1. 前端在js中new Image(), 并附带上标注信息(通过设置cookie, 自动发送到服务端). 
    2. 后端可以只用header来响应"204 No Content".
    3. 通过监控Image对象的onerror和onload事件来检测发送状态
    4. 与请求script文件相比好处是: 1. 不需要额外注入DOM; 2. 不会造成阻塞
    5. 与其他图片格式相比: 体积小, GIF < JPG < PNG < BMP
- 为什么使用图片, GIF
    1. 数据放在图片的url后面, 可以避免跨域
    2. 无阻塞, 不插入DOM, 不会影响用户体验
    3. 相比使用XHR发送GET请求, 性能更好一些
    4. 通过监控Image对象的onerror和onload事件来检测发送状态


### 第50题:
考察: 原型
```javascript
Number.prototype.add = function (num) { return this + num }
Number.prototype.minus = function (num) { return this - num }
```
扩展:  
- [JavaScript 浮点数陷阱及解法](https://github.com/camsong/blog/issues/9)
- [双精度浮点数构成分析](http://www.binaryconvert.com/result_double.html?decimal=050)


### 第51题
考察: Vue源码  
- Object.defineProperty 有什么缺陷？
1. 无法直接监控数组下标的变化(消耗性能太大), 数组通过下标改变时无法实时响应
2. Object.defineProperty需要遍历对象的属性达到监控对象的效果(可能需要深度遍历), 而Proxy可以直接监控整个对象,并返回一个新的对象
3. Proxy可以直接监控数组, 还可以监控动态增加的属性和删除属性



```javascript
var a = []
Object.defineProperty(a, "1", {
    get() {
        console.log( "get 1:", a["_1"])
        return a["_1"]
    },
    set(v) {
        console.log("set 1:", v)
        a["_1"] = v
    }
})

var b = []
var bProxy = new Proxy(b, {
    get (target, key, receiver) {
        console.log("get", target, key, receiver)
        return target[key]
    },

    set (target, key, value, receiver) {
        console.log('set', target, key, value, receiver)
        target[key] = value
    }
})

```

### 第52题
考察: CSS  
怎么让一个 div 水平垂直居中?
- 父元素设置: "display: `flex`; justify-content: center; align- items: center;"
- 设置`BFC`, 父元素设置:"position: relative",子元素:"position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);"
- 父元素设置: "display: `grid`", 子元素: "justify-self: center; align-self:center"
- 父元素设置: "display: `flex`;", 子元素: "margin: auto"

上述方法均可用在不定宽高的情况下


### 第53题
考察: 运算符执行顺序  
```javascript
// 执行顺序
//1. 虽然赋值是从右到左, 但是 . 运算符比 = 的优先度要高, 所以 a/b 的值此时为: {n: 1, x: undefined}
//2. 因为是同一条语句, 所以当 a = {n:2} 执行时, 等号左边的 a.x 的a不会重新赋值, 所以仍旧引用旧对象b.x的地址为它赋值, 此时: a = {n:2}, b = {n:1, x:a)
//3. 所以最终打印 undefined, {n: 2}
```

### 第54题
考察: 算法 冒泡排序 时间复杂度  
```javascript
// 冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？
// 实现, 时间复杂度 O(n^2)
function bubble(arr){
    for(let i = arr.length; i > 0; i--) {
        let pos = 0 // 优化, 以上一轮确定的位置为本轮终点
        for(let j = 1; j < i; j++) {
            if(arr[j - 1] > arr[j]) {
                [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]
                pos = j
            }
        }
        i = pos
    }
    return arr
}
```

### 第55题
考察: 数组  
```javascript
function t(obj) {
    // 此处不能用Array(12), 以为会得到松散数组(不存在key: 1,2,3,4 的数组), map,filter等遍历函数无法正常遍历
    return Array.from({length: 12}).map((v, i) => obj[i + 1] || null)
}
```


### 第56题
考察: SleepTask的类实现   
```javascript
    // 分析: 1. 由于是链式调用, 而且函数执行的顺序也不确定, 所以需要把函数放到一个队列中, 等待逐个调用
    function LazyMan(name) {
        this.name = name
        this.taskQueue = []      // 由于存在sleepFirst, 所以需要维护一个taskQueue

        console.log(`Hi I am ${this.name}`)

        this.sleep = (delay) => {
            this.taskQueue.push(resolve => setTimeout(resolve, delay * 1000))
            return this;
        }

        this.sleepFirst = (delay) => {
            this.taskQueue.unshift(resolve => setTimeout(resolve, delay * 1000))
            return this;
        }

        this.eat = (food) => {
            this.taskQueue.push((resolve) => {
                console.log(`I am eating ${food}`)
                resolve && resolve()
            })
            return this;
        }

        async function next(){
            let task = this.taskQueue.shift()
            while (task) {
                await new Promise(resolve => task(resolve))
                task = this.taskQueue.shift()
            }
        }

        setTimeout(next.bind(this), 0)
        return this
    }
    LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
```


### 第57题
考察: CSS隐藏元素  
- opacity: 0
    - 透明度设为0, 文档仍然渲染元素
    - 占据空间, 内容不可见, 可以点击, GPU加速时不触发回流重绘
    - 株连性: 非继承属性, 子孙节点也将消失
- visibility: hidden
    - 可见状态设为隐藏, 文档仍然渲染元素
    - 占据空间, 内容不可见, 不可以点击, 触发重绘
    - 继承属性, 子孙节点可以修改属性使自己显示
- display: none
    - 设为不展示, 渲染树中消失
    - 不再占用空间, 不可以点击, 触发回流重排
    - 株连性: 非继承属性, 子孙节点也将消失
    


### 第58题
考察: ES6 箭头函数    

1. 箭头函数的this继承自定义函数时所在的对象且不可以改变(this继承自定义时的this)  
2. 箭头函数没有arguments对象
3. 不可以使用 yield, 所以无法当做Generator函数使用
4. 不能使用new 命令, 因为: 
    - 没有this无法调用call和apply, 
    - 没有prototype所以无法赋值给新对象的__proto__



### 第59题
考察: 数组算法  
```javascript
    function arrMixed(arr1, arr2) {
        let arr = []
        let hash = {}
        for(let i = 0; i < arr1.length; i++) {
            if(!hash[arr1[i]]) hash[arr1[i]] = 0
            hash[arr1[i]] += 1
        }
        for(let i = 0; i < arr2.length; i++) {
            if(hash[arr2[i]]) {
                arr.push(arr2[i])
                hash[arr2[i]] -= 1
            }
        }
        return arr
    }
```


### 第60题
考察: CSS  
1. max-width: 300px
2. transform: scale(0.625, 1)
3. zoom: 0.625


### 第61题
考察: token加密  
以JWT(JSON WEB TOKEN)为例:
1. 后端生成一个随机数(secret)
2. 利用这个随机数使用加密算法加密payload(账号密码), 得到token, 发送给前端
3. token通常保存在cookie中, 前端每次请求时自动带上token, 服务端会验证是否存在此token, 并解密token


### 第62题
考察: redux  
1. 纯函数无副作用, 即reducer要确保返回新的state只受oldState和action影响
2. reducer基于纯函数的设计, 接收oldState和action并返回newState, 可以实现时间旅行


### 第63题
考察: 轮播图  
1. wrapper 设置为相对定位, 隐藏超出部分
2. ul 设置为绝对定位, 长度无限长, 使li可以排成一行
3. li 向左浮动排成一列
4. 由于BFC机制, 可以给ul设置 left 距离, 可以使不同的li显示与wrapper范围内
5. 当轮播到最后一个元素时, 使它变为绝对定位并设置负的left, 使它位于第一个li的左边, 并把ul的left 设置为 一个元素的长度, 令其过渡的时候看起来是连续的
6. 当又回到第一个元素时, 把最后一个元素复原
[参考](../note/HTML/demo/lunbo.html)


### 第64题
考察: promise  
```javascript
Promise.prototype.finally = function (cb) {
    let p = this.constructor
    return this.then(
        value => p.resolve(cb()).then(() => value),
        reason => p.resolve(cb()).then(() => { throw reason })
    )
}
```

### 第65题
考察: JS基础  
点语法更快: 
1. 点语法不需要判断[]里可能是变量的情况
2. AST树解析出来的内容也少一点, 推测执行速度也会快一点 


### 第66题
考察: AST树, 转译  
1. 使用`babel-core`之类的库, 读取JS文件得到AST树
2. 按照一定的规则转换,修改AST
3. 将修改后的AST转换成普通代码


### 第67题
考察: 数组编程  
```javascript
function transform(arr) {
    arr = arr.sort((a, b) => a - b)
    let res = [[arr[0]]]
    let p = 0
    let maxNum = arr[0]
    for(let i = 1; i < arr.length; i++) {
        let v = arr[i]
        if(~~(v / 10) != ~~(maxNum / 10)) p += 1
        if(!res[p]) res[p] = []


        if(v > maxNum) {
            maxNum = v
            res[p].push(v)
        }
    }

    return res
}

```


### 第68题
考察: 移动端 retina  
1. viewport + rem
2. background-image
3. 伪类 + transform scaleY(0.5)
4. border-image
5. box-shadow

[使用Flexible实现手淘H5页面的终端适配](https://github.com/amfe/article/issues/17)


### 第69题
考察: 字符串编程  
```javascript
function negate(raw){
    let str = ""
    for(let i = 0; i < raw.length; i++) {
        let v = raw[i]
        let _v = raw[i].toLocaleUpperCase()
        if(v == _v) _v = raw[i].toLocaleLowerCase()
        str += _v
    }

    return str
}
```


### 第70题
考察: webpack, 热更新  
1. 模块热替换(HMR)

[Webpack HMR 原理解析](https://zhuanlan.zhihu.com/p/30669007)


### 第71题
考察: 字符串匹配算法, KMP算法  

```javascript
// 暴力解法
function fn(S, T){
    let n = S.length, m = T.length
    if(m > n) return -1
    
    for(let i = 0; i < n - m; i++){
        let ret = true
        for(let j = 0; j < m; j++){
            if(S[i + j] !== T[j]) ret = false
        }
        if(ret) return i
    }
    return -1
}

// KMP  动态调整T串往后移的位置
```


### 第72题
考察: 原生API熟悉度  
- for循环没有任何额外的参数调用栈和上下文, 减少堆栈创建内存分配.
- forEach实际函数是 array.forEach(function(currentValue, index, array), thisValue) 


### 第73题
考察: 布局, CSS, 格式上下文  

- BFC: Block Formatting Context, 块级格式上下文
- IFC: Inline Formatting Context, 内联格式上下文
- GFC: Grid Formatting Context, 网格布局格式上下文
- FFC: Flex Formatting Context, 自适应格式上下文



### 第111题
思路: 队列, 类AST  

```javascript
function flagObj(obj, key = '', res = {}) {
    if (typeof obj != 'object' || !obj) {
        res[key] = obj
    } else {
        for (let k in obj) {
            flagObj(obj[k], `${key ? key + '.' : key}${k}`, res)
        }
    }
    return res
}

```


### 第114题
思路: 正则匹配连续字符  

```javascript
// 'abcaakjbb' => {'a':2,'b':2}
// 'abbkejsbcccwqaa' => {'c':3}
// 注意：题目说的是连续出现，注意连续二字
function searchLongChar(str) {
    // 正则找出连续出现一次以上的字符
    const arr = str.match(/(.)\1+/g)
    let max = Math.max(...arr.map(v => v.length))
    return arr.reduce((pre, next) => {
        if(next.length < max) return pre
        pre[next[0]] = max
        return pre
    }, {})
}
searchLongChar('abbkejsbcccwqaa')
```


### 第152题
思路: 递归  

```javascript
function normalize(s) {
    let reg = /(\w+)/g
    let values = s.match(reg)
    let res = {}
    let tmp = {}
    for (let v of values) {
        if (tmp.value) {
            tmp.children = { value: v }
            tmp = tmp.children
        } else {
            res.value = v
            tmp = res
        }
    }
    return res
}
```


### 第158题
思路: splice(start, deleteCount, ...addItems)  
```javascript
Array.prototype._splice = function splice(start, deleteCount = this.length - start, ...addItems) {
    while (start < 0) {
        start = this.length + start
    }
    if(start > this.length) start = 0

    let restItems = addItems.concat(this.slice(start + deleteCount))
    let removeItems = this.slice(start, start + deleteCount)
    
    let addIndex = start
    for(let v of restItems) {
        this[addIndex++] = v
    }
    this.length = addIndex
    return removeItems
}
```
